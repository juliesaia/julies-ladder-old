<!-- server needs to check if the author has access to the requested channel id -->
<!-- channel ids need to be randomly generated by the server upon invites -->
<!-- hash username? -->

<template>
  <template v-if="user.steam">
    <!-- <p><img :src="user.steam.photos[2].value" alt="Your Avatar Image" /></p> -->
    <!-- <p>ID: {{user.steam.id}}</p> -->
    <!-- <p>Name: {{user.steam.displayName}}</p> -->
  </template>
  <template v-if="loading">

    <div class="mx-auto mt-10 loader"></div>

  </template>
  <template v-else>
    <div class="grid grid-cols-5 h-85vh grid-rows-[auto,1fr]">
        <!-- <div> -->
        <img class=" col-start-2 col-span-3 my-5 mx-auto w-1/6" alt="Vue logo" src="../assets/AetherLadder.png" />
        <!-- <div v-if="!usernamesubmit" class="col-start-3">
          <form @submit.prevent="connect" class="mx-auto">
            <input v-model="username" type="text" id="message" class="w-full rounded-lg border-transparent flex-1 appearance-none border border-gray-300  py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-purple-900 focus:border-transparent" placeholder="Username..."/>
          </form>
        </div> -->
        <!-- <template v-if="usernamesubmit"> -->
        <div id="online-list" class="flex flex-col col-start-1 bg-white rounded-lg mx-6 text-gray-700 text-center overflow-auto">
          <span class="inline-block font-bold my-3">Online</span>
          <hr/>
          <div class="flex-1 overflow-auto">
            <Menu as="div" v-for="other_user in users" >
              <template v-if="other_user.id != user.id">
                <MenuButton :disabled="!other_user.ready || channels.some((el) => other_user.name == el.name)" class="w-full h-3rem hover:bg-gray-200 focus:outline-none" :class="other_user.ready && !channels.some((el) => other_user.name == el.name)? '' : 'bg-gray-400 hover:bg-gray-400 text-gray-500 cursor-not-allowed'">
                  <div  >{{other_user.name}}</div>
                </MenuButton>
                
                <MenuItems class="h-10" >
                  <MenuButton>
                    Invite? <button @click="inviteHandler(other_user)" class="bg-green-500 rounded-lg w-15 hover:opacity-80 focus:outline-none"><CheckIcon class="h-5 text-white align-text-top "/></button>
                  </MenuButton>
                </MenuItems>
              </template>

            </Menu>
          </div>
        </div>
        <div  class=" col-span-3 flex flex-col ">
          
            <TabGroup @change="changedTab" :defaultIndex="0" :key="ihateheadlessui">
              <TabList id="tabs" class="">
                <!-- <Tab><div class="text-center font-bold py-3 px-3 bg-white text-black rounded-t-lg">{{chat_to["name"] ? chat_to["name"] : "Global"}}</div></Tab> -->
                <Tab v-for="channel in channels" v-slot="{ selected }" as="span" :ref="el => { if (channel.name == 'Global') globalTab = el }">
                  <button :class="[
                  'text-center text-white font-bold py-3 px-3  rounded-t-lg focus:outline-none',
                  selected ? 'bg-white text-black cursor-default' : 'border-t border-l border-r border-gray-400 text-gray-400'
                  ]">{{channel.name}}   <XIcon v-if="channel.name != 'Global'" @click = "closeChannel(channel)" class="h-2ex relative top-2px cursor-pointer"/></button>
                </Tab>
              </TabList>
              <TabPanel v-for="channel in channels" class="flex flex-grow h-0">
                <template v-if="channel.lobby_link != null">
                  <div class="absolute grid grid-cols-3 w-3/5">
                    <div  class="text-black my-5 p-5 bg-purple-300 rounded border border-purple-900 text-center col-start-2 ">
                      <template v-if="channel.lobby_link.split('/')[4] == 'undefined'">
                        <span>Lobby link not active!</span>
                        <br/>
                        <span v-if="channel.users[0].id == user.id">
                          Don't forget to open the lobby in your client and click Reset Lobby
                        </span>
                        <span v-else>
                          Tell your opponent to open the lobby in their client and click Reset Lobby
                        </span>
                      </template>
                      <template v-else>
                        <span>Join the lobby </span><a class="text-blue-600" :href="channel.lobby_link" target="_blank">here</a>!
                        <!-- <br/> -->
                        <!-- <span>Don't forget to open the lobby in your client</span> -->
                      </template>
                    </div>
                    <button @click="resetLobby(channel)" v-if="channel.lobby_link.split('/')[5] == user.steam.id" type="button" class="w-1/2 h-12 col-start-3 mt-8 mx-auto  px-4  bg-purple-800 hover:bg-purple-700 focus:ring-purple-500 focus:ring-offset-purple-200 text-white transition ease-in duration-200 text-center font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2  rounded-lg " >
                      Reset Lobby
                    </button>
                  </div>                  
                </template>
                <div disabled class="overflow-auto flex-grow flex flex-col-reverse border h-full border-gray-300 w-full py-2 px-4 bg-white text-gray-700 " id="comment" name="comment">
                <div class="" v-for="message in channel.messages">
                  <span class="font-bold">{{message.author.name}}</span> <span>{{message.content}}</span>
                </div>
              </div>
              </TabPanel>
            </TabGroup>
          <!-- </div> -->
        
          <form @submit.prevent="submit" class="">
            <input autocomplete="off" autocorrect="off" autocapitalize="off" id="chat" v-model="chatmessage"  type="text" ref="message_el" class="w-full rounded-b-lg border-transparent flex-1 appearance-none border border-gray-300  py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-purple-900 focus:border-transparent" placeholder="Chat..."/>
          </form>
        </div>

        <!-- <div class="flex flex-col col-start-1 bg-white rounded-lg mx-6 text-gray-700 text-center overflow-auto">
          <span class="inline-block font-bold my-3">Online</span>
          <hr/>
          <div class="flex-1 overflow-auto"> -->
        <div id="invites" class="flex flex-col justify-center bg-white rounded-lg mx-6 text-gray-700 text-center relative overflow-auto pb-14">
          <span class="inline-block font-bold my-3">Invites</span>
          <hr/>
          <div class=" flex-1 overflow-auto">
            <Menu as="div" v-for="invite in invites" class="hover:bg-gray-200">
              <MenuButton  class="w-full h-3rem focus:outline-none ">
                  <div  >{{invite.users[0].name}}</div>
                  
                </MenuButton>
                
                <MenuItems class="h-10" >
                  <MenuItem as="div">
                    Accept? <button @click="acceptHandler(invite)" class="bg-green-500 rounded-lg w-15 hover:opacity-80 focus:outline-none"><CheckIcon class="h-5 text-white align-text-top "/></button>
                    <button @click="rejectHandler(invite)" class="bg-red-500 rounded-lg w-15 hover:opacity-80 focus:outline-none"><XIcon class="h-5 text-white align-text-top "/></button>
                  </MenuItem>
                </MenuItems>
            </Menu>
            
          </div>
          <div v-if="user.ready" class="mx-2 absolute bottom-0 left-0 right-0">
            <button type="button" @click="ready" class="col-start-3 mt-10 mb-2 py-2 px-4  bg-green-800 hover:bg-green-700 focus:ring-green-500 focus:ring-offset-green-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2  rounded-lg ">
              Ready!
            </button>
          </div>
          <div v-else class="mx-2 absolute bottom-0 left-0 right-0">
            <button id="not-ready" type="button" @click="ready" class="w-full col-start-3 mt-10 mb-2 py-2 px-4  bg-red-800 hover:bg-red-700 focus:ring-red-500 focus:ring-offset-red-200 text-white transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2  rounded-lg ">
              Not Ready
            </button>
          </div>
        </div>
        <div class="mt-4 col-start-5 mx-auto">
          <span class="text-white"> Enable Notifications </span>
          <Switch
            v-model="notifenabled"
            :class="notifenabled ? 'bg-green-600' : 'bg-purple-700'"
            class=" inline-flex items-center h-6 rounded-full w-11 my-auto"
          >
            <span class="sr-only">Enable notifications</span>
            <span
              :class="notifenabled ? 'translate-x-6' : 'translate-x-1'"
              class="inline-block w-4 h-4 transform bg-white rounded-full"
            />
          </Switch>
        </div>
      </div>
  </template>
  <!-- </div> -->
</template>

<script setup lang="ts">

import { io } from "socket.io-client"

import { ref, reactive, nextTick, computed, watch } from "vue"

import { onBeforeRouteLeave} from 'vue-router'

import { Menu, MenuButton, MenuItems, MenuItem, TabGroup, TabList, Tab, TabPanels, TabPanel, Switch } from '@headlessui/vue'

import { CheckIcon, XIcon } from "@heroicons/vue/outline"

import { useStore } from 'vuex'

import "../arrayRemove"

import "../intro.js"

// import { introJs } from "intro.js"



const store = useStore()

var socket = undefined


var chatmessage = ref("")
var username = ref("")
var usernamesubmit = ref(false)
var loading = ref(false)

var ihateheadlessui = ref(0);
var notifenabled = ref(false);
// var user = ref({name: null, id: null, steam: null, ready: false})

var user = computed(() => {
  return store.state.user
})

var users = ref([])
var invites = ref([])
var channels = ref([{id: 0, name: "Global", messages: [], users: [], lobby_link: null}])
var channel = ref(channels.value[0])
var lobby_link = ref("")

var server = ref({name: "Server", id: 0})
const message_el = ref(null)

var globalTab = ref(null)

loading.value = true;

const backend_url = import.meta.env.DEV ? "http://localhost:3000/" :  "https://julies-ladder.cheesypota.to";

socket = reactive(io(backend_url, {
  withCredentials: true
}))
// console.log(socket);

socket.emit("username", username.value, async (response) => {
  
  loading.value = false;
  // console.log(response.users);
  
  users.value = response.users
  // user.value = response.user
  store.commit("set", response.user)

  for (var other_user of users.value){
    if (other_user.id != user.value.id){
      const connected_message = {author: server, content: other_user.name + " connected", channel_id: 0}
      channels.value[0].messages.unshift(connected_message)
    }
  }
  lobby_link.value = `steam://joinlobby/383980/${user.value.steam._json.lobbysteamid}/${user.value.steam.id}`

  await nextTick()
  message_el.value.focus()
  //@ts-ignore
  introJs().setOptions({
    steps: [{
      title: "Welcome!",
      intro: "Don't forget to open a Rivals lobby before inviting people!"
    },
    {
      element: document.querySelector("#online-list"),
      intro: "Invite people to a lobby here"
    },
    {
      element: document.querySelector("#tabs"),
      intro: "Switch chatrooms here"
    },
    {
      element: document.querySelector("#invites"),
      intro: "Manage your invites here"
    },
    {
      element: document.querySelector("#not-ready"),
      intro: "Use this button to ready up and start receiving invites"
    },
    {
      element: document.querySelector("#chat"),
      intro: "Chat here, and have fun!"
    }]
  }).start();
})

socket.on("message", (message) => {
  
  const channel = channels.value.find(channel => channel.id == message.channel_id)
  const channel_index = channels.value.findIndex(channel => channel.id == message.channel_id)
  
  document.querySelector("#tabs").children[channel_index].firstElementChild.classList.toggle("text-gray-400")
  document.querySelector("#tabs").children[channel_index].firstElementChild.classList.toggle("border-gray-400")

  channel.messages.unshift(message) // push front
})

socket.on("adduser", (user) => {
  users.value.push(user)
  const connected_message = {author: server, content: user.name + " connected", channel_id: 0}
  channels.value[0].messages.unshift(connected_message)
  
})

socket.on("removeuser", (user) => {
  // console.log(user);
  // console.log(users.value);
  
  ihateheadlessui.value++
  // users.value.remove(user)
  users.value = users.value.filter((el) => {return el.id != user.id})
  // channels.value = channels.value.filter((el) => {return el.id == 0 || !el.users.some((el2) => {return user.id == el2.id})}) 
  // invites.value = invites.value.filter((el) => {!el.users.some((el2) => {return user.id == el2.id})}) 
  channels.value = channels.value.filter((el) => {return el.id == 0 || !(el.name == user.name)}) 
  invites.value = invites.value.filter((el) => {return !(el.name == user.name)}) 
  const disconnected_message = {author: server, content: user.name + " disconnected", channel_id: 0}
  channels.value[0].messages.unshift(disconnected_message)
  channel.value = channels.value[0]
  // document.getElementById(globalTab.value.id).click() 
  // for (var channel of channels.value){
  //   if (channel.users.find((channel_user) => channel_user.id == user.id) != -1){
  //     channel.users.remove(user)
  //     const disconnected_message = {author: server, content: user.name + " disconnected", channel_id: channel.id}
  //     channel.messages.unshift(disconnected_message)
  //   }
  // }
})

socket.on("receiveInvite", (channel) => {
  // if (invites.value.every((el) => el.id != channel.id)){
  if (invites.value.every((el) => el.users[0].id != channel.users[0].id)){
    invites.value.push(channel)
    if (notifenabled.value){
      var notification = new Notification(`${channel.users[0].name} invited you to a game on Julie's Ladder!`);
    }
  }
})

socket.on("inviteAcceptedSender", (invite) => {
  if (invites.value.findIndex((el) => invite.id == el.id)){
    var channel = channels.value.find(channel => channel.id == invite.id)
    const channel_index = channels.value.findIndex(channel => channel.id == invite.id)
  

    document.querySelector("#tabs").children[channel_index].firstElementChild.classList.toggle("text-gray-400")
    document.querySelector("#tabs").children[channel_index].firstElementChild.classList.toggle("border-gray-400")
    channel.users = invite.users
    channel.messages = invite.messages
    // channel.messages.unshift({author: server, content: invite.users[1].name + " connected", channel: channel})
    // channels.value.push(channel)
    var index = invites.value.findIndex((el) => invite.id == el.id)
    invites.value.splice(index, 1)
  }
})

socket.on("inviteRejectedSender", (invite) => {
  channels.value = channels.value.filter((el) => el.id != invite.id)
  if (invites.value.findIndex((el) => invite.id == el.id)){
    var index = invites.value.findIndex((el) => invite.id == el.id)
    invites.value.splice(index, 1)
    
  }
})

socket.on("ready", (user) => {

  
  for (var other_user of users.value){
    if (other_user.id == user.id){
      other_user.ready = user.ready
      if (other_user.ready == true){
        users.value.remove(other_user)
        users.value.unshift(other_user)
      }
      else{
        users.value.remove(other_user)
        users.value.push(other_user)
      }

      
      return
    }
  }
})

socket.on("channelClosed", (other_channel) => { 
  // console.log("channel closed");
  ihateheadlessui.value++;
  // channels.value.remove(channel)
  // console.log(other_channel);
  // console.log(invites.value);
  
  
  channels.value = channels.value.filter((el) => el.id != other_channel.id)
  invites.value = invites.value.filter((el) => el.name != other_channel.name)
  channel.value = channels.value[0]
  // document.getElementById(globalTab.value.id).click() 
})

socket.on("newLink", (channel) => { 
  if (user.value.steam.id == channel.lobby_link.split("/")[5]){
    lobby_link.value = channel.lobby_link;
  }
  for (let el of channels.value){
    if (el.id == channel.id){
      el.lobby_link = channel.lobby_link
    }
  }
  for (let el of invites.value){
    if (el.lobby_link.split("/")[5] == channel.lobby_link.split("/")[5]){
      el.lobby_link = channel.lobby_link
    }
  }
})

usernamesubmit.value = true

onBeforeRouteLeave((to, from) => {
  if (socket){
    socket.disconnect()
  }
})

function submit(){ 
  if (chatmessage.value.trim() == ""){
    return;
  }
  // console.log(chatmessage.value);
  var message = {"author": user.value, "content": chatmessage.value, "channel_id": channel.value.id}
  // console.log(message);
  
  socket.emit("message", message)
  chatmessage.value = ""
}

function inviteHandler(invitee){
  socket.emit("createChannel", {invitee: invitee, lobby_link: lobby_link.value}, (channel) => {
    ihateheadlessui.value++;
    channels.value.push(channel)
    // channels.value[channels.value.length - 1].messages.unshift({author: server, content: user.value.name + " connected", channel: channel})
  })
}

function acceptHandler(invite){
  
  invite.users.push(user.value)
  const connected_message = {author: server, content: user.value.name + " connected", channel_id: invite.channel_id}
  invite.messages.unshift(connected_message)
  channels.value.push(invite)
  ihateheadlessui.value++;
  // remove invite after accept
  var index = invites.value.findIndex((el) => invite.id == el.id)
  invites.value.splice(index, 1)
  socket.emit("inviteAcceptedReceiver", invite)
}

function rejectHandler(invite){
  var index = invites.value.findIndex((el) => invite.id == el.id)
  invites.value.splice(index, 1)
  socket.emit("inviteRejectedReceiver", invite)
}

function changedTab(index){
  channel.value = channels.value[index]
}

function ready(){
  user.value.ready = !user.value.ready
  socket.emit("ready", user.value)
}

async function closeChannel(channel){
  // channels.value.remove(channel)
  // await nextTick();
  // channel = channels.value[0]
  socket.emit("closeChannel", channel) 
}

function resetLobby(channel){
  socket.emit("resetLobby", channel);
}

watch(notifenabled, (notifenabled, prevvalue) => {
  if (notifenabled == true && Notification.permission !== "denied"){
    Notification.requestPermission().then(function (permission) {
      if (permission === "granted") {
        notifenabled = true;
      }
      else {
        notifenabled = false;
      }
    });
  }
  else{
    notifenabled = false;
  }
  
})

</script>

<style>
@import "../assets/introjs.css";
.loader {
  border: 16px solid ; /* Light grey */
  border-top: 16px solid #581c87; /* Purple */
  border-radius: 50%;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
  color: white;
}

/* .introjs-tooltip-header{
  color: black;
}

.introjs-tooltiptext {
  color: #1c1e21;
} */



@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
/* #app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
} */
</style>
